% !TEX root = paper.tex

% Any macro that is actually used should have a comment explaining what it is for.
% Please fight macro pollution and remove the macros that are not used.

\newcommand{\defeq}{\mathrel{\overset{\text{\tiny def}}{=}}} % Definitional equality

\newcommand{\pl}[1]{\textsc{#1}} % the name of a programming language

\newcommand{\lambdaAEff}{$\lambda_{\text{\ae}}$} % the name of the calculus

% BNF grammars
\newcommand{\bnfis}{\mathrel{\;{:}{:}{=}\ }}
\newcommand{\bnfor}{\mathrel{\;\big|\ \ }}

%%%%% Semantic concepts

%%% Sets

\newcommand{\One}{\mathbb{1}} % singleton set as denotation of unit type
\newcommand{\one}{\star} % canonical element of the singleton set
\newcommand{\Zero}{\mathbb{0}} % empty set as denotation of empty type

\newcommand{\Bool}{\mathbb{B}} % two-element set of booleans
\newcommand{\true}{\mathbf{true}} % constant true
\newcommand{\false}{\mathbf{false}} % constant false

\newcommand{\expto}{\Rightarrow} % set exponentiation
\newcommand{\pair}[2]{\langle #1 , #2 \rangle} % pairing

\newcommand{\lifted}[1]{#1_\bot} % lifting monad
\newcommand{\idte}[4]{\mathbf{ifdef}~#1~\mathbf{then}~#2 \mapsto #3~\mathbf{else}~#4} % test if element of a lifted set is defined (non-bottom) or not, and then use it in the then branch

\newcommand{\ite}[3]{\mathbf{if}~#1~\mathbf{then}~#2~\mathbf{else}~#3} % if-then-else used in semantic definitions


%%% Signatures

\newcommand{\Tree}[2]{\mathrm{Tree}_{#1}\left(#2\right)} % The tree algebra for an operation signature
\newcommand{\retTree}[1]{\mathsf{return}\,#1} % the inclusion of generators into trees

\newcommand{\opsym}[1]{\mathsf{#1}} % a custom operation symbol
\newcommand{\op}{\opsym{op}} % a generic operation symbol

\newcommand{\sig}{\Sigma} % the global signature of signal and interrupt names

\renewcommand{\o}{o} % effect annotation describing possible outgoing operations
\renewcommand{\i}{\iota} % effect annotation describing possible incoming operations

\newcommand{\opincomp}[2]{{\mathsf{#1}}\,{\tmkw{\downarrow}}\,#2} % action of incoming interrupt on computation types
\newcommand{\opincompp}[2]{{\mathsf{#1}}\,{\tmkw{\downarrow\downarrow}}\,#2} % action of a list of incoming interrupts on computation types

%%% Theories
\newcommand{\eq}{\mathrm{Eq}} % a set of equations

\newcommand{\FreeAlg}[2]{\mathrm{Free}_{#1}\left(#2\right)} % Free algebra for a signature generated by a set
\newcommand{\lift}[1]{#1^\dagger} % the Kleisli lifting of a map
\newcommand{\freelift}[1]{#1^\ddagger} % the lifting of a map induced by the free model property

\newcommand{\M}{\mathcal{M}} % a generic model for a theory
\newcommand{\Mcarrier}{\vert \mathcal{M} \vert} % the carrier of a generic model

\newcommand{\T}{T} % A generic monad


%%% Example effect theories

\newcommand{\sigget}{\mathsf{get}}
\newcommand{\sigset}{\mathsf{set}}


%%%%% Types

\newcommand{\at}{\mathbin{!}} % the ! sign, with proper spacing
\newcommand{\att}{\mathbin{!!}} % the !! sign, with proper spacing

%% Value types

\newcommand{\tysym}[1]{\mathsf{#1}}
\newcommand{\tybase}{\tysym{b}} % a base type
\newcommand{\tyunit}{\tysym{1}} % the unit ground type
\newcommand{\tyint}{\tysym{int}} % the integer ground type
\newcommand{\tystring}{\tysym{string}} % the integer ground type
\newcommand{\tylist}[1]{\tysym{list}~\tysym{#1}} % the list ground type
\newcommand{\tyempty}{\tysym{0}} % the empty ground type
\newcommand{\typrod}[2]{#1 \times #2} % product type
\newcommand{\tysum}[2]{#1 + #2} % sum type
\newcommand{\tyfun}[2]{#1 \to #2} % user function type
\newcommand{\typromise}[1]{\langle #1 \rangle} % type of promises

%% Computation types

\newcommand{\tycomp}[2]{#1 \at #2} % computation type

%% Process types

\newcommand{\tyrun}[3]{#1 \att (#2,#3)} % type of the run M process
\newcommand{\typar}[2]{#1 \mathbin{\tmkw{\vert\vert}}  #2} % type of parallel processes
\newcommand{\tyC}{C} % meta variable ranging over process types
\newcommand{\tyD}{D} % meta variable ranging over process types

%%%%% Display of source code in math mode

\newcommand{\tm}[1]{\mathsf{#1}} % the source code font
\newcommand{\tmkw}[1]{\tm{\color{keywordColor}#1}} % source code keyword, colored

\newcommand{\tmpromise}[1]{\langle #1 \rangle} % completed promise

\newcommand{\tmconst}[1]{\tm{#1}}
\newcommand{\tmunit}{()} % the element of the unit type
\newcommand{\tmpair}[2]{( #1 , #2 )} % ordered pair
\newcommand{\tminl}[2][]{\tmkw{inl}_{#1}\,#2} % left injection
\newcommand{\tminr}[2][]{\tmkw{inr}_{#1}\,#2} % right injection
\newcommand{\tmfun}[2]{{\mathop{\tmkw{fun}}}\; (#1) \mapsto #2} % function abstraction
\newcommand{\tmfunano}[2]{{\mathop{\tmkw{fun}}}\; #1 \mapsto #2} % function abstraction (no type annotation expected)
\newcommand{\tmapp}[2]{#1\,#2} % application

\newcommand{\tmreturn}[2][]{\tmkw{return}_{#1}\, #2} % pure computation
\newcommand{\tmlet}[3]{\tmkw{let}\; #1 = #2 \;\tmkw{in}\; #3} % let-binding
% \newcommand{\tmletrec}[5][]{\tmkw{let}\;\tmkw{rec}\; #2\; #3 #1 = #4 \;\tmkw{in}\; #5} % recursive definitions

\newcommand{\tmop}[4]{\tm{#1}\;(#2, #3. #4)} % operation call
\newcommand{\tmopin}[3]{\tmkw{\downarrow}\, \tm{#1}\,(#2, #3)} % incoming interrupt
\newcommand{\tmopout}[3]{\tmkw{\uparrow}\,\tm{#1}\, (#2, #3)} % outgoing signal
\newcommand{\tmopoutbig}[3]{\tmkw{\uparrow}\,\tm{#1}\, \big(#2, #3\big)} % outgoing signal with big brackets
\newcommand{\tmopoutgen}[2]{\tmkw{\uparrow}\,\tm{#1}\, #2} % generic variant of outgoing signal

\newcommand{\tmmatch}[3][]{\tmkw{match}\;#2\;\tmkw{with}\;\{#3\}_{#1}} % match statement

\newcommand{\tmawait}[3]{\tmkw{await}\;#1\;\tmkw{until}\;\tmpromise{#2}\;\tmkw{in}\;#3} % awaiting for a promise to be completed

\newcommand{\tmwith}[5]{\tmkw{promise}\; (\tm{#1}\; #2 \mapsto #3)\; \tmkw{as}\; #4\; \tmkw{in}\; #5} % interrupt hook
\newcommand{\tmwithre}[6]{\tmkw{promise}\; (\tm{#1}\; #2 \, #3 \mapsto #4)\; \tmkw{as}\; #5\; \tmkw{in}\; #6} % interrupt hook
%\newcommand{\tmwith}[6]{\tmkw{promise}\; (\tm{#1}\; #2 \mapsto #3)\; \tmkw{as}\; #4 \of \typromise{#5}\; \tmkw{in}\; #6} % interrupt hook

\newcommand{\tmrun}[1]{\tmkw{run}\; #1} % running a computation as a process
\newcommand{\tmpar}[2]{#1 \mathbin{\tmkw{\vert\vert}} #2} % parallel composition of processes

%%% Operational semantics

\newcommand{\reduces}{\leadsto} % small-step reduction
\newcommand{\tyreduces}{\rightsquigarrow} % reduction of process types

\newcommand{\E}{\mathcal{E}} % evaluation context for computations
\renewcommand{\H}{\mathcal{H}} % signal hoisting context
\newcommand{\F}{\mathcal{F}} % evaluation context for processes

%%% Typing rules

\newcommand{\types}{\vdash} % typing judgement
\newcommand{\of}{\mathinner{:}} % the colon in a typing judgement

\newcommand{\sub}{\sqsubseteq} % subtyping relation

\newcommand{\coopinfer}[3]{\inferrule*[Lab={\color{rulenameColor}#1}]{#2}{#3}}

%%% Meta-theory

\newcommand{\CompResult}[2]{\mathsf{CompRes}\langle#1 \,\vert\, #2\rangle} % top-level result forms of individual computations
\newcommand{\RunResult}[2]{\mathsf{RunRes}\langle#1 \,\vert\, #2\rangle} % local (under-signal) result forms of individual computations

\newcommand{\Result}[2]{\mathsf{Res}\langle#1 \,\vert\, #2\rangle} % top-level result forms of computations

\newcommand{\ProcResult}[1]{\mathsf{ProcRes}\langle #1 \rangle} % top-level result forms of parallel processes
\newcommand{\ParResult}[1]{\mathsf{ParRes}\langle #1 \rangle} % intermediate result forms of parallel processes

%%% Maths

\newcommand{\cond}[3]{\mathsf{if}\;#1\;\mathsf{then}\;#2\;\mathsf{else}\;#3} % single line conditional

\newcommand{\carrier}[1]{\vert #1 \vert} % carrier of a cpo
\newcommand{\order}[1]{\sqsubseteq_{#1}} % partial order of a cpo
\newcommand{\lub}[1]{\bigsqcup_n \langle #1 \rangle} % least upper bound of an omega-chain

\newcommand{\Pow}[1]{\mathcal{P}(#1)} % powerset
\newcommand{\sem}[1]{[\![#1]\!]} % semantic bracket

\makeatletter
\providecommand*{\cupdot}{%     % disjoint union of sets
  \mathbin{%
    \mathpalette\@cupdot{}%
  }%
}
\newcommand*{\@cupdot}[2]{%
  \ooalign{%
    $\m@th#1\cup$\cr
    \hidewidth$\m@th#1\cdot$\hidewidth
  }%
}
\makeatother


%%% Redex highlighting

\definecolor{redexColor}{rgb}{0.83, 0.83, 0.83} % the color of highlighted redexes
\newcommand{\highlightgray}[1]{{\setlength{\fboxsep}{1.5pt}\colorbox{redexColor}{$#1$}}} % highlight redexes with gray(ish) background
\newcommand{\highlightwhite}[1]{{\setlength{\fboxsep}{1.5pt}\colorbox{white}{$#1$}}} % highlight redexes with white background

